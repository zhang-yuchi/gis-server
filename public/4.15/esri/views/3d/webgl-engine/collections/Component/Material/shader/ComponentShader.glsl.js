// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.15/esri/copyright.txt for details.
//>>built
define("require exports ../../../../../../../core/tsSupport/makeTemplateObjectHelper ../../../../../support/earthUtils ./ComponentData.glsl ./VertexDiscardByOpacity.glsl ../../../../core/shaderLibrary/ForwardLinearDepth.glsl ../../../../core/shaderLibrary/Slice.glsl ../../../../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../../../../core/shaderLibrary/attributes/VertexColor.glsl ../../../../core/shaderLibrary/attributes/VertexNormal.glsl ../../../../core/shaderLibrary/attributes/VertexPosition.glsl ../../../../core/shaderLibrary/output/OutputDepth.glsl ../../../../core/shaderLibrary/output/OutputHighlight.glsl ../../../../core/shaderLibrary/shading/ComputeMaterialColor.glsl ../../../../core/shaderLibrary/shading/ComputeNormalTexture.glsl ../../../../core/shaderLibrary/shading/ComputeShadingNormal.glsl ../../../../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../../../../core/shaderLibrary/shading/ReadBaseColorTexture.glsl ../../../../core/shaderLibrary/shading/ReadShadowMap.glsl ../../../../core/shaderLibrary/util/AlphaDiscard.glsl ../../../../core/shaderModules/interfaces ../../../../core/shaderModules/ShaderBuilder ../../../../shaders/Overlay.glsl".split(" "),
function(ka,f,d,R,S,T,U,V,W,X,Y,Z,aa,ba,ca,da,g,ea,fa,ga,ha,h,c,ia,ja){Object.defineProperty(f,"__esModule",{value:!0});f.attributeLocations={position:0,normal:1,normalCompressed:1,color:2,uv0:3,uvRegion:4,componentIndex:5};f.build=function(b){var a=new ia.ShaderBuilder;a.include(Z.VertexPosition,b);a.include(Y.VertexNormal,b);a.include(X.VertexColor,b);a.include(W.TextureCoordinateAttribute,b);a.include(U.ForwardLinearDepth,b);a.include(S.ComponentData,b);a.include(h.DiscardOrAdjustAlpha,b);a.include(V.Slice,
b);a.include(ga.ReadBaseColorTexture,b);a.include(T.VertexDiscardByOpacity,b);if(1===b.pbrMode||2===b.pbrMode)a.include(fa.PhysicallyBasedRenderingParameters,b),a.include(da.ComputeNormalTexture,b);3===b.output&&1===b.componentData?a.vertex.code.add(c.glsl(k||(k=d(["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "],["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "])))):
a.vertex.code.add(c.glsl(l||(l=d(["\n      #define discardShadows(castShadows) {}\n    "],["\n      #define discardShadows(castShadows) {}\n    "]))));var e=b.overlayEnabled&&0===b.output&&4===b.pbrMode;b.overlayEnabled&&(a.include(ja.Overlay,b),0===b.viewingMode?a.vertex.code.add(c.glsl(m||(m=d(["\n      const float invEarthRadius \x3d ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "],["\n      const float invEarthRadius \x3d ",
";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "])),c.glsl.float(1/R.earthRadius))):a.vertex.code.add(c.glsl(n||(n=d(["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "],["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "])))));e&&(a.varyings.add("tbnTangent","vec3"),a.varyings.add("tbnBiTangent","vec3"),a.varyings.add("groundNormal","vec3"));a.vertex.code.add(c.glsl(p||(p=d(["\n    void main() {\n      bool castShadows;\n      vec4 externalColor \x3d forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a \x3c ",
") {\n        // Discard this vertex\n        gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ","\n\n      ","\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "],["\n    void main() {\n      bool castShadows;\n      vec4 externalColor \x3d forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a \x3c ",
") {\n        // Discard this vertex\n        gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ","\n\n      ","\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "])),c.glsl.float(h.symbolAlphaCutoff),e?c.glsl(q||(q=d(["\n        ","\n        "],["\n        ","\n        "])),0===b.viewingMode?c.glsl(r||(r=d(["\n        groundNormal \x3d normalize(positionWorld());\n        tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent \x3d normalize(cross(groundNormal, tbnTangent));"],
["\n        groundNormal \x3d normalize(positionWorld());\n        tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent \x3d normalize(cross(groundNormal, tbnTangent));"]))):c.glsl(t||(t=d(["\n        groundNormal \x3d vec3(0.0, 0.0, 1.0);\n        tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n        tbnBiTangent \x3d normalize(cross(groundNormal, tbnTangent));"],["\n        groundNormal \x3d vec3(0.0, 0.0, 1.0);\n        tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n        tbnBiTangent \x3d normalize(cross(groundNormal, tbnTangent));"])))):
"",b.overlayEnabled?c.glsl(u||(u=d(["setOverlayVTC(projectOverlay(position));"],["setOverlayVTC(projectOverlay(position));"]))):""));0===b.output&&(a.include(ca.ComputeMaterialColor,b),a.include(g.ComputeShadingNormal,b),a.include(ea.EvaluateSceneLighting,b),e&&(a.fragment.uniforms.add("ovInnerNormalTex","sampler2D"),a.fragment.uniforms.add("ovOuterNormalTex","sampler2D")),b.receiveShadows?(a.include(ha.ReadShadowMap,b),a.fragment.code.add(c.glsl(v||(v=d(["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "],
["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "]))))):a.fragment.code.add(c.glsl(w||(w=d(["\n        float evaluateShadow() { return 0.0; }\n      "],["\n        float evaluateShadow() { return 0.0; }\n      "])))),a.fragment.code.add(c.glsl(x||(x=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor \x3d computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ",
"\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor \x3d computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ","\n    "])),b.overlayEnabled?
c.glsl(y||(y=d(["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n        materialColor \x3d materialColor * (1.0 - overlayColor.a) + overlayColor;"],["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n        materialColor \x3d materialColor * (1.0 - overlayColor.a) + overlayColor;"]))):"")),1===b.pbrMode||2===b.pbrMode?(a.fragment.code.add(c.glsl(z||(z=d(["\n        ","\n        vec3 normalVertex \x3d shadingNormalWorld();\n        float additionalIrradiance \x3d 0.02 * lightingMainIntensity[2];\n      "],
["\n        ","\n        vec3 normalVertex \x3d shadingNormalWorld();\n        float additionalIrradiance \x3d 0.02 * lightingMainIntensity[2];\n      "])),1===b.pbrMode?c.glsl(A||(A=d(["\n        applyPBRFactors();\n        if (int(externalColorMixMode) \x3d\x3d 3) {\n          mrr \x3d vec3(0.0, 0.6, 0.2);\n        }"],["\n        applyPBRFactors();\n        if (int(externalColorMixMode) \x3d\x3d 3) {\n          mrr \x3d vec3(0.0, 0.6, 0.2);\n        }"]))):"")),b.hasNormalTexture?a.fragment.code.add(c.glsl(B||
(B=d(["\n        mat3 tangentSpace \x3d computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n        "],["\n        mat3 tangentSpace \x3d computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n        "])))):a.fragment.code.add(c.glsl(C||(C=d(["\n        vec3 shadingNormal \x3d normalVertex;\n        "],["\n        vec3 shadingNormal \x3d normalVertex;\n        "])))),
a.fragment.code.add(c.glsl(D||(D=d(["","\n      "],["","\n      "])),0===b.viewingMode?c.glsl(E||(E=d(["vec3 normalGround \x3d normalize(positionWorld());"],["vec3 normalGround \x3d normalize(positionWorld());"]))):c.glsl(F||(F=d(["vec3 normalGround \x3d vec3(0.0, 0.0, 1.0);"],["vec3 normalGround \x3d vec3(0.0, 0.0, 1.0);"]))))),a.fragment.code.add(c.glsl(G||(G=d(["\n        vec3 viewDir \x3d normalize(vPositionWorldCameraRelative);\n        float ssao \x3d 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight \x3d evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor \x3d vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        "],
["\n        vec3 viewDir \x3d normalize(vPositionWorldCameraRelative);\n        float ssao \x3d 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight \x3d evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor \x3d vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        "]))))):(b.receiveShadows?a.fragment.code.add(c.glsl(H||
(H=d(["\n      float shadow \x3d evaluateShadow();\n        "],["\n      float shadow \x3d evaluateShadow();\n        "])))):0===b.viewingMode?a.fragment.code.add(c.glsl(I||(I=d(["\n      float additionalAmbientScale \x3d _oldHeuristicLighting(positionWorld());\n      float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "],["\n      float additionalAmbientScale \x3d _oldHeuristicLighting(positionWorld());\n      float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "])))):
a.fragment.code.add(c.glsl(J||(J=d(["\n      float shadow \x3d 0.0;\n      "],["\n      float shadow \x3d 0.0;\n      "])))),a.fragment.code.add(c.glsl(K||(K=d(["\n      float ambientOcclusion \x3d evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight \x3d evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor \x3d vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ",
"\n      "],["\n      float ambientOcclusion \x3d evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight \x3d evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor \x3d vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ","\n      "])),e?c.glsl(L||(L=d(["\n          vec4 overlayWaterMask \x3d getOverlayColor(ovInnerNormalTex, ovOuterNormalTex, vtcOverlay);\n          float waterNormalLength \x3d length(overlayWaterMask);\n          if (waterNormalLength \x3e 0.95) {\n            mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterColor \x3d getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix);\n            // un-gamma the ground color to mix in linear space\n            vec4 groundColor \x3d vec4(pow(shadedColor.rgb, vec3(2.2)), shadedColor.w);\n            waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n            shadedColor \x3d vec4(delinearizeGamma(waterColor).rgb, materialColor.a);\n          }"],
["\n          vec4 overlayWaterMask \x3d getOverlayColor(ovInnerNormalTex, ovOuterNormalTex, vtcOverlay);\n          float waterNormalLength \x3d length(overlayWaterMask);\n          if (waterNormalLength \x3e 0.95) {\n            mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterColor \x3d getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix);\n            // un-gamma the ground color to mix in linear space\n            vec4 groundColor \x3d vec4(pow(shadedColor.rgb, vec3(2.2)), shadedColor.w);\n            waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n            shadedColor \x3d vec4(delinearizeGamma(waterColor).rgb, materialColor.a);\n          }"]))):
""))),a.fragment.code.add(c.glsl(M||(M=d(["\n        gl_FragColor \x3d highlightSlice(shadedColor, vPositionWorldCameraRelative);\n      }\n    "],["\n        gl_FragColor \x3d highlightSlice(shadedColor, vPositionWorldCameraRelative);\n      }\n    "])))));if(1===b.output||3===b.output)a.include(aa.OutputDepth,b),a.fragment.code.add(c.glsl(N||(N=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "],
["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "]))));2===b.output&&(a.include(g.ComputeShadingNormal,b),a.fragment.code.add(c.glsl(O||(O=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha \x3d ",
";\n        gl_FragColor \x3d vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha \x3d ",";\n        gl_FragColor \x3d vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "])),
2===b.normalType?"0.0":"1.0")));4===b.output&&(a.include(ba.OutputHighlight),a.fragment.code.add(c.glsl(P||(P=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ","\n\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ",
"\n\n        outputHighlight();\n      }\n    "])),b.overlayEnabled?c.glsl(Q||(Q=d(["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n\n        if (overlayColor.a \x3d\x3d 0.0) {\n          gl_FragColor \x3d vec4(0.0);\n          return;\n        }"],["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n\n        if (overlayColor.a \x3d\x3d 0.0) {\n          gl_FragColor \x3d vec4(0.0);\n          return;\n        }"]))):"")));return a};var k,l,m,n,r,t,q,u,p,v,w,y,x,A,z,B,C,E,
F,D,G,H,I,J,L,K,M,N,O,Q,P});